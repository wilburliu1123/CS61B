**Redirection and piping.**
For many applications, typing input data as a standard input stream from the terminal window is untenable because doing so limits our program's processing power by the amount of data that we can type. similarly, we often want to save the information printed on the standard output stream for later use. We can use operating system mechanisms to address both issues.
- Redirecting standard output to a file. By adding a simple directive to the command that invokes a program, we can redirect its standard output to a file, either for permanent storage or for input to some other program at a later time. For examples, the command specifies that the standard output stream is not to be printed in the terminal window, but instead is to be written to a text file named data.txt. Each call to StdOut.print() or StdOut.println() appends text at the end of that file. In this example, the end result is a file that contains 1,000 random values.
- Redirecting standard output from a file. Similarly, we can redirect standard input so that StdIn reads data from a file instead of the terminal window. For example, the command reads a sequence of numbers from the file data.txt and computes their average value. Specifically , the < symbol is directive to implement the standard input stream by reading from the file data.txt instead of by waiting for the user to type something into the terminal window. When the program calls StdIn.readDouble(), the operating system reads the value from the file. This facility to redirect standard input from a file enables us to process huge amounts of data from any source with our programs, limited only by the size of the files that we can store.
- Connecting two programs. The most flexible way to implement the stadard input and standard output abstractions is to specify that they are implemented by our own programs! This mechanism is called piping. For example, the following command specifies that the standard output for RandomSeq and the standard input stream for Average are the same stream.
- Fileters. For many comman tasks, it is convenient to think of each program as a filter that converts a srandard input stream to a standard output stream in some way, RangeFilter.java takes two command-line arguments and prints on standard output those numbers from standard input that fall within the specified range. Your operating system also provides a number of filters. For example, the sort filters puts the lines on standard input in sorted order:
Another useful filter is more, which reads data from standard input and display it in your terminal window one screenful at a time. For example, if you type "java RandomSeq 1000| more" You will see as many numbers as fit in your terminal window, but more will wait for you to hit the space bar before displaying each succeeeding screenful.

**Standard Drawing.** Now we introduce a simple abstracction for producing drawings as output . we imagine an abstract drawing device capable of drawing lines and points on a two-dimentional canvas. The device is capable of responding to the commands that our programs issue in the form of calls to static methods in StdDraw. The primary interface consists of two kinds of methods: drawing commands that cause the device to take an action (such as drawing a line or drawing a point) and control commands that set parameters such as the pen size or the coordinate scales.
- Basic drawing commands. We first consider the drawing commands:
These methods are nearly self-documenting StdDraw.line(x0, y0, x1, y1) draws a straight line segment connecting the point(x0,y0) with the point x1,y1. The default coordinate scale is the unit square. The standard implementation displays the canvas in a window on your computer's screen, with with black lines and points on a white background. Your first drawing outline and filled shapes. SdDraw also includes methods to draw circles, rectangles, and arbitrart polygons. Each shape defines an outline. When the method name is just the shape name, that outline is traced by the drawing pen. When the method name begins with filled, the named shape is instead filled solid, not traced.
The arguments for circle() define a circle of radius r; the arguments for square() define a square of side length 2r centered on the given point; and the arguments for plygon() define a sequence of points that we connect by lines, including one from the last point to the first point.
